---
meta:
  title: "@remix-run/loader | Remix"
---

import { Link } from "react-router-dom";

# @remix-run/loader

This package is to be included only by files located inside of your `loaders/` directory. You may want to reference the <Link to="fetch">Remix and Web Fetch API</Link> page as well.

## Loader Signature

Remix passes some arguments to your loaders and you return an object or a response.

```js
module.exports = ({ params, url, context }) => {
  return objectOrResponse;
};
```

## Loader arg: params

Route params are passed to your loader. If you have a loader at `loaders/invoices/$invoiceId.js` then Remix will parse out the `invoiceId` and pass it to your loader. This is useful for fetching data from an API or database.

```js
// if the user visits /invoices/123
module.exports = ({ params }) => {
  params.invoiceId; // "123"
};
```

## Loader arg: url

This is a [Web API URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) instance with information about the url requested. You can read the MDN docs to see all of it's properties.

Proabably the most useful property is `searchParams`, which is an instance of [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).

```js
// say the user is at /some/route?foo=bar
module.exports = ({ url }) => {
  let foo = url.searchParams.get("foo");
};
```

## Loader arg: context

This is the context you passed in to your deployment wrapper's `getLoaderContext()` function. It's a way to bridge the gap between the platform's request/response API with your remix app.

Say your express server (or your serverless function handler) looks something like this:

```js
const { createRequestHandler } = require("@remix-run/express");

app.get(
  "*",
  createRequestHandler({
    getLoaderContext(req, res) {
      // this becomes the loader context
      return { req, res };
    },
  })
);
```

And then your loader can access it.

```js
// loaders/some-loader.js
module.exports = ({ context }) => {
  let { req } = context.req;
  // read a cookie
  req.cookies.session;

  // write a cookie
  res.cookie("session", "...");
};
```

## Returning objects

You can return plain JavaScript objects from your loaders that will be made available to your <Link to="../route-module">route modules</Link>.

```js
// some fake database, not part of remix
let db = require("../db");

module.exports = async () => {
  let users = await db.query("users");
  return users;
};
```

## Returning Response Instances

You can return Web API Response objects from your loaders. Here's a pretty basic JSON response:

```js
// some fake database, not part of remix
let db = require("../db");

module.exports = async () => {
  let users = await db.query("users");

  let body = JSON.stringify(users);

  return new Response(body, {
    headers: {
      "content-type": "application/json",
    },
  });
};
```

See also:

- <Link to="../fetch">Remix Web Fetch API</Link>
- [MDN Response Docs](https://developer.mozilla.org/en-US/docs/Web/API/Response)

## Response Headers

As you saw earlier, you can return plain objects from loaders. Remix takes that object and turns it into a Response. However, you lose the ability to set headers and status codes.

For example, let's say you're fetching versioned information from your database. This data never changes, you can tell the client and CDNs to cache that forever.

Let's say this is the loader for the route `/contracts/$name/$version` and it's a publically available page:

```js
let db = require("../db");

module.exports = async ({ params }) => {
  // version 1 of the contract will never change
  let contract = await db.query(`
    select * from contracts
    where name = '${params.name}'
    and version = '${params.version}'
  `);

  let body = JSON.stringify(contract);

  return new Response(body, {
    headers: {
      // cache that sucker for a year for everybody
      "cache-control": "public, max-age=31540000000",
      "content-type": "application/json",
    },
  });
};
```

This response can then be cached by the user's browser and your CDN pretty much forever. After the first visitor requests it, the CDN caches the response. Now, when any other user requests it, the CDN sends the cached response without ever hitting your server.

## Response Status Codes

Loaders can return Responses with status codes. The initial HTML document will return the status code of the first non-200 data loader in the nested routes.

This is very useful for "not found" data making it's way all the way down to the browser's UI with a real 404 status code, 500s, etc.

```js
module.exports = async () => {
  let res = db.query("users").where("id", "=", "_why");
  if (res === null) {
    return new Response("not found", {
      status: 404,
    });
  } else {
    return res;
  }
};
```

This is also very useful for 500 error handling. You don't need to render a different page, instead, handle the error, send the data, and send a 500 response to the app.

```js
module.exports = async () => {
  try {
    let stuff = await something();
  } catch (error) {
    let body = JSON.stringify({ error: true, message: error.message });
    return new Response(body, {
      status: 500,
      headers: {
        "content-type": "application/json",
      },
    });
  }
};
```

Now your route component can deal with it:

```jsx
export default function Something({ data }) {
  if (data.error) {
    return <ErrorMessage>{data.message}</ErrorMessage>;
  }
  // ...
}
```

The initial server render will get a 500 for this page, and client side transitions will get it also.

## `json` helper

This is a shortcut for creating `application/json` responses.

```js
const { json } = require("@remix-run/loader");
module.exports = () => {
  // basic
  return json({ any: "thing " });
};
```

You can also pass a status code and headers:

```js
const { json } = require("@remix-run/loader");
module.exports = () => {
  return json(
    { not: "coffee" },
    {
      status: 418,
      headers: {
        "cache-control": "no-store",
      },
    }
  );
};
```

## `notFound` helper

This is a shortcut for creating 404 responses.

```js
const { notFound } = require("@remix-run/loader");
module.exports = () => {
  let result = db.query(query);
  if (result == null) {
    return notFound();
  }
  // ...
};
```
